<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Összefésülő Rendezés Vizualizáció</title>

    <!-- Include Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Include React and ReactDOM from CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Include Babel for JSX support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Helvetica, Arial, sans-serif;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <div
      id="root"
      class="container"></div>

    <script type="text/babel">
      const {useState, useEffect} = React;

      function MergeSortVisualization() {
        const [array, setArray] = useState([]);
        const [colorArray, setColorArray] = useState([]);
        const [auxiliaryArray, setAuxiliaryArray] = useState([]);
        const [isSorting, setIsSorting] = useState(false);
        const [sorted, setSorted] = useState(false);
        const [speed, setSpeed] = useState(500);
        const [history, setHistory] = useState([]);
        const [historyIndex, setHistoryIndex] = useState(-1);
        const [autoPlay, setAutoPlay] = useState(false);
        const [comparisons, setComparisons] = useState(0);
        const [merges, setMerges] = useState(0);
        const [currentStep, setCurrentStep] = useState('');
        const [animations, setAnimations] = useState([]);
        const [currentAnimationIndex, setCurrentAnimationIndex] = useState(0);

        // Color constants
        const UNSORTED = 'bg-blue-500';
        const COMPARING = 'bg-red-500';
        const OVERWRITING = 'bg-purple-500';
        const SORTED = 'bg-green-500';
        const AUXILIARY = 'bg-yellow-500';
        const SORTED_SECTION = 'bg-green-300';

        const generateRandomArray = () => {
          const newArray = Array.from(
            {length: 10},
            () => Math.floor(Math.random() * 100) + 1
          );
          const newColorArray = new Array(newArray.length).fill(UNSORTED);
          const newAuxArray = new Array(newArray.length).fill(0);

          setArray(newArray);
          setColorArray(newColorArray);
          setAuxiliaryArray(newAuxArray);
          setSorted(false);
          setComparisons(0);
          setMerges(0);
          setCurrentStep('Indításra kész');
          setIsSorting(false);
          setAutoPlay(false);

          // Generate and store all animations
          const newAnimations = getMergeSortAnimations([...newArray]);
          setAnimations(newAnimations);
          setCurrentAnimationIndex(0);

          // Reset history
          const initialState = {
            array: [...newArray],
            colorArray: [...newColorArray],
            auxiliaryArray: [...newAuxArray],
            sorted: false,
            comparisons: 0,
            merges: 0,
            currentStep: 'Indításra kész',
          };

          setHistory([initialState]);
          setHistoryIndex(0);
        };

        const resetDemo = () => {
          setIsSorting(false);
          setAutoPlay(false);
          if (history.length > 0) {
            const initialState = history[0];
            setArray([...initialState.array]);
            setColorArray([...initialState.colorArray]);
            setAuxiliaryArray([...initialState.auxiliaryArray]);
            setSorted(initialState.sorted);
            setComparisons(initialState.comparisons);
            setMerges(initialState.merges);
            setCurrentStep(initialState.currentStep);
            setCurrentAnimationIndex(0);
            setHistoryIndex(0);
          }
        };

        // Helper function to create merge sort animations
        const getMergeSortAnimations = (array) => {
          const animations = [];
          if (array.length <= 1) return animations;

          const auxiliaryArray = array.slice();
          mergeSortHelper(
            array,
            0,
            array.length - 1,
            auxiliaryArray,
            animations
          );

          return animations;
        };

        const mergeSortHelper = (
          mainArray,
          startIdx,
          endIdx,
          auxiliaryArray,
          animations
        ) => {
          if (startIdx === endIdx) return;

          const middleIdx = Math.floor((startIdx + endIdx) / 2);

          // Add animation for division
          animations.push({
            type: 'divide',
            start: startIdx,
            middle: middleIdx,
            end: endIdx,
          });

          // Recursively sort the two halves
          mergeSortHelper(
            auxiliaryArray,
            startIdx,
            middleIdx,
            mainArray,
            animations
          );
          mergeSortHelper(
            auxiliaryArray,
            middleIdx + 1,
            endIdx,
            mainArray,
            animations
          );

          // Merge the two halves
          doMerge(
            mainArray,
            startIdx,
            middleIdx,
            endIdx,
            auxiliaryArray,
            animations
          );
        };

        const doMerge = (
          mainArray,
          startIdx,
          middleIdx,
          endIdx,
          auxiliaryArray,
          animations
        ) => {
          // Add animation for starting merge
          animations.push({
            type: 'merge-start',
            leftStart: startIdx,
            leftEnd: middleIdx,
            rightStart: middleIdx + 1,
            rightEnd: endIdx,
          });

          let k = startIdx;
          let i = startIdx;
          let j = middleIdx + 1;
          const tempArray = [];

          // Start merging
          while (i <= middleIdx && j <= endIdx) {
            // Compare elements
            animations.push({
              type: 'compare',
              indices: [i, j],
              values: [auxiliaryArray[i], auxiliaryArray[j]],
            });

            if (auxiliaryArray[i] <= auxiliaryArray[j]) {
              // Copy from left side
              animations.push({
                type: 'copy',
                from: i,
                to: k,
                value: auxiliaryArray[i],
              });
              tempArray[k - startIdx] = auxiliaryArray[i];
              mainArray[k++] = auxiliaryArray[i++];
            } else {
              // Copy from right side
              animations.push({
                type: 'copy',
                from: j,
                to: k,
                value: auxiliaryArray[j],
              });
              tempArray[k - startIdx] = auxiliaryArray[j];
              mainArray[k++] = auxiliaryArray[j++];
            }
          }

          // Copy remaining elements from left side
          while (i <= middleIdx) {
            animations.push({
              type: 'copy',
              from: i,
              to: k,
              value: auxiliaryArray[i],
            });
            tempArray[k - startIdx] = auxiliaryArray[i];
            mainArray[k++] = auxiliaryArray[i++];
          }

          // Copy remaining elements from right side
          while (j <= endIdx) {
            animations.push({
              type: 'copy',
              from: j,
              to: k,
              value: auxiliaryArray[j],
            });
            tempArray[k - startIdx] = auxiliaryArray[j];
            mainArray[k++] = auxiliaryArray[j++];
          }

          // Add animation for completed merge
          animations.push({
            type: 'merge-complete',
            start: startIdx,
            end: endIdx,
            tempArray: tempArray,
          });
        };

        // Execute a single animation step
        const executeNextAnimationStep = () => {
          if (currentAnimationIndex >= animations.length) {
            // All animations finished
            if (!sorted) {
              const newColorArray = Array(array.length).fill(SORTED);

              const newState = {
                array: [...array],
                colorArray: newColorArray,
                auxiliaryArray: [...auxiliaryArray],
                sorted: true,
                comparisons,
                merges,
                currentStep: 'Rendezés befejezve!',
              };

              setHistory([...history, newState]);
              setHistoryIndex(history.length);

              setColorArray(newColorArray);
              setSorted(true);
              setCurrentStep('Rendezés befejezve!');
              setIsSorting(false);
              setAutoPlay(false);
            }
            return;
          }

          const animation = animations[currentAnimationIndex];
          let newArray = [...array];
          let newColorArray = Array(array.length).fill(UNSORTED);
          let newAuxArray = [...auxiliaryArray];
          let newComparisons = comparisons;
          let newMerges = merges;
          let newStep = '';

          if (animation.type === 'divide') {
            newStep = `Tömb felosztása ${animation.start} indextől ${animation.end} indexig`;

            // Highlight the section being divided
            for (let i = animation.start; i <= animation.end; i++) {
              newColorArray[i] = COMPARING;
            }
          } else if (animation.type === 'compare') {
            newComparisons++;
            newStep = `${animation.values[0]} és ${animation.values[1]} elemek összehasonlítása`;

            // Highlight elements being compared
            newColorArray[animation.indices[0]] = COMPARING;
            newColorArray[animation.indices[1]] = COMPARING;
          } else if (animation.type === 'copy') {
            newStep = `${animation.value} érték másolása a(z) ${animation.to} indexre`;

            // Update main array
            newArray[animation.to] = animation.value;

            // Update auxiliary view
            newAuxArray[animation.to] = animation.value;

            // Highlight the elements involved
            newColorArray[animation.from] = AUXILIARY;
            newColorArray[animation.to] = OVERWRITING;
          } else if (animation.type === 'merge-start') {
            newMerges++;
            newStep = `Résztömbök összefésülése [${animation.leftStart}-${animation.leftEnd}] és [${animation.rightStart}-${animation.rightEnd}]`;

            // Highlight subarrays to be merged
            for (let i = animation.leftStart; i <= animation.leftEnd; i++) {
              newColorArray[i] = AUXILIARY;
            }
            for (let i = animation.rightStart; i <= animation.rightEnd; i++) {
              newColorArray[i] = AUXILIARY;
            }
          } else if (animation.type === 'merge-complete') {
            newStep = `Összefésülés befejezve ${animation.start} indextől ${animation.end} indexig`;

            // Mark the merged section as sorted
            for (let i = animation.start; i <= animation.end; i++) {
              newColorArray[i] = SORTED_SECTION;
            }
          }

          // Add state to history
          const newState = {
            array: newArray,
            colorArray: newColorArray,
            auxiliaryArray: newAuxArray,
            sorted: false,
            comparisons: newComparisons,
            merges: newMerges,
            currentStep: newStep,
          };

          setHistory([...history.slice(0, historyIndex + 1), newState]);
          setHistoryIndex(historyIndex + 1);

          // Update current state
          setArray(newArray);
          setColorArray(newColorArray);
          setAuxiliaryArray(newAuxArray);
          setComparisons(newComparisons);
          setMerges(newMerges);
          setCurrentStep(newStep);
          setCurrentAnimationIndex(currentAnimationIndex + 1);
        };

        // Function for the step button
        const stepForward = () => {
          if (!sorted) {
            executeNextAnimationStep();
          }
        };

        // Function for the step backward button
        const stepBackward = () => {
          if (historyIndex > 0) {
            const prevState = history[historyIndex - 1];
            setArray([...prevState.array]);
            setColorArray([...prevState.colorArray]);
            setAuxiliaryArray([...prevState.auxiliaryArray]);
            setSorted(prevState.sorted);
            setComparisons(prevState.comparisons);
            setMerges(prevState.merges);
            setCurrentStep(prevState.currentStep);
            setHistoryIndex(historyIndex - 1);
            setCurrentAnimationIndex(currentAnimationIndex - 1);
          }
        };

        // Function to start automatic playback
        const startSorting = () => {
          if (!sorted) {
            setIsSorting(true);
            setAutoPlay(true);
          }
        };

        // Function to pause automatic playback
        const pauseSorting = () => {
          setAutoPlay(false);
        };

        // Initialize the visualization
        useEffect(() => {
          generateRandomArray();
        }, []);

        // Handle automatic playback
        useEffect(() => {
          let timer;
          if (autoPlay && !sorted) {
            timer = setTimeout(() => {
              executeNextAnimationStep();
            }, speed);
          }
          return () => clearTimeout(timer);
        }, [array, autoPlay, speed, currentAnimationIndex, historyIndex]);

        return (
          <div className="flex flex-col p-4 bg-gray-100 rounded-lg shadow-md">
            <h2 className="text-2xl font-bold text-center mb-4">
              Összefésülő Rendezés Vizualizáció
            </h2>

            <div className="mb-4 p-2 bg-white rounded shadow">
              <h3 className="text-lg font-semibold mb-2">
                Hogyan működik az összefésülő rendezés:
              </h3>
              <p className="text-sm mb-1">
                1. Felosztás: Rekurzívan felezzük a tömböt egészen addig, amíg
                egy elemű részekre nem bomlik
              </p>
              <p className="text-sm mb-1">
                2. Hódítás: Az egy elemű tömbök már rendezettek
              </p>
              <p className="text-sm mb-1">
                3. Összeolvasztás: A rendezett résztömböket összefésüljük egy
                teljes rendezett tömbbé
              </p>
              <p className="text-sm">
                4. Időbonyolultság: minden esetben O(n log n)
              </p>
            </div>

            <div className="h-64 flex items-end justify-center space-x-1 mb-6 border-b-2 border-gray-400 bg-white rounded p-2">
              {array.map((value, index) => (
                <div
                  key={index}
                  className={`w-8 flex flex-col items-center justify-end ${colorArray[index]} transition-all duration-300`}
                  style={{height: `${Math.max(value * 2, 24)}px`}}>
                  <div className="text-white font-bold mb-1">{value}</div>
                </div>
              ))}
            </div>

            <div className="h-16 flex items-end justify-center space-x-1 mb-4 bg-white rounded p-2">
              <div className="text-sm font-semibold mr-2">Segéd tömb:</div>
              {auxiliaryArray.map((value, index) => (
                <div
                  key={index}
                  className={`w-8 flex flex-col items-center justify-center ${
                    value > 0 ? AUXILIARY : 'bg-gray-200'
                  } h-8`}>
                  <div className="text-white font-bold">
                    {value > 0 ? value : ''}
                  </div>
                </div>
              ))}
            </div>

            <div className="text-center mb-4 bg-white p-2 rounded shadow">
              <p className="text-sm font-semibold">{currentStep}</p>
            </div>

            <div className="mb-4 flex justify-between items-center">
              <div className="flex space-x-2">
                <button
                  onClick={generateRandomArray}
                  className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">
                  Új Tömb
                </button>
                <button
                  onClick={resetDemo}
                  className="px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600">
                  Újraindítás
                </button>
              </div>

              <div className="flex space-x-2">
                <button
                  onClick={stepBackward}
                  disabled={historyIndex <= 0}
                  className={`px-3 py-1 rounded ${
                    historyIndex <= 0
                      ? 'bg-gray-300 cursor-not-allowed'
                      : 'bg-purple-500 text-white hover:bg-purple-600'
                  }`}>
                  ◀
                </button>

                {autoPlay ? (
                  <button
                    onClick={pauseSorting}
                    className="px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600">
                    Szünet
                  </button>
                ) : (
                  <button
                    onClick={startSorting}
                    disabled={sorted}
                    className={`px-3 py-1 rounded ${
                      sorted
                        ? 'bg-gray-300 cursor-not-allowed'
                        : 'bg-green-500 text-white hover:bg-green-600'
                    }`}>
                    Indítás
                  </button>
                )}

                <button
                  onClick={stepForward}
                  disabled={sorted}
                  className={`px-3 py-1 rounded ${
                    sorted
                      ? 'bg-gray-300 cursor-not-allowed'
                      : 'bg-teal-500 text-white hover:bg-teal-600'
                  }`}>
                  Lépés
                </button>

                <button
                  onClick={stepForward}
                  disabled={
                    sorted || currentAnimationIndex >= animations.length
                  }
                  className={`px-3 py-1 rounded ${
                    sorted || currentAnimationIndex >= animations.length
                      ? 'bg-gray-300 cursor-not-allowed'
                      : 'bg-purple-500 text-white hover:bg-purple-600'
                  }`}>
                  ▶
                </button>
              </div>

              <div className="flex items-center">
                <span className="mr-2 text-sm">Sebesség:</span>
                <input
                  type="range"
                  min="50"
                  max="1000"
                  step="50"
                  value={1050 - speed}
                  onChange={(e) => setSpeed(1050 - parseInt(e.target.value))}
                  className="w-24"
                />
              </div>
            </div>

            <div className="grid grid-cols-3 gap-4 text-center bg-white p-2 rounded shadow">
              <div>
                <p className="text-sm font-semibold">
                  Felosztások: <span className="text-blue-600">{merges}</span>
                </p>
              </div>
              <div>
                <p className="text-sm font-semibold">
                  Összehasonlítások:{' '}
                  <span className="text-blue-600">{comparisons}</span>
                </p>
              </div>
              <div>
                <p className="text-sm font-semibold">
                  Összefésülések:{' '}
                  <span className="text-green-600">{merges}</span>
                </p>
              </div>
              <div className="col-span-3 mt-2">
                <div className="flex justify-center space-x-4">
                  <div className="flex items-center">
                    <div className="w-4 h-4 bg-blue-500 mr-1"></div>
                    <span className="text-xs">Rendezetlen</span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-4 h-4 bg-red-500 mr-1"></div>
                    <span className="text-xs">Összehasonlítás</span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-4 h-4 bg-yellow-500 mr-1"></div>
                    <span className="text-xs">Segéd tömb</span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-4 h-4 bg-purple-500 mr-1"></div>
                    <span className="text-xs">Felülírás</span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-4 h-4 bg-green-300 mr-1"></div>
                    <span className="text-xs">Rendezett szakasz</span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-4 h-4 bg-green-500 mr-1"></div>
                    <span className="text-xs">Teljesen rendezett</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<MergeSortVisualization />);
    </script>
  </body>
</html>
